# yaml-language-server: $schema=https://raw.githubusercontent.com/prefix-dev/recipe-format/main/schema.json
schema_version: 1

context:
  name: "my-cpp-app" # TODO: Replace with actual application name
  version: "1.0.0" # TODO: Replace with actual version

package:
  name: ${{ name }}
  version: ${{ version }}

source:
  # TODO: Replace with actual source URL
  url: https://github.com/example/${{ name }}/archive/v${{ version }}.tar.gz
  sha256: "0000000000000000000000000000000000000000000000000000000000000000" # TODO: Update hash

build:
  number: 0
  # Using nushell for cross-platform builds
  script:
    interpreter: nu
    env:
      CMAKE_ARGS: ${{ CMAKE_ARGS }}
      CPU_COUNT: ${{ nprocs }}
    content: |
      print $"Building ($env.PKG_NAME) version ($env.PKG_VERSION)..."

      # Determine the correct install prefix based on platform
      let install_prefix = if ($nu.os-info.name == "windows") {
          $env.LIBRARY_PREFIX
      } else {
          $env.PREFIX
      }

      # Platform-specific binary directory
      let bin_dir = if ($nu.os-info.name == "windows") {
          ($env.LIBRARY_PREFIX | path join "bin")
      } else {
          ($env.PREFIX | path join "bin")
      }

      # Check if we have a CMake project
      if ("CMakeLists.txt" | path exists) {
          print "Building with CMake..."

          # Create build directory
          mkdir build
          cd build

          # Base CMake arguments
          mut cmake_args = [
              "-GNinja",
              "-DCMAKE_BUILD_TYPE=Release",
              $"-DCMAKE_INSTALL_PREFIX=($install_prefix)",
              $"-DCMAKE_PREFIX_PATH=($install_prefix)",
          ]

          # TODO: Add project-specific CMake options
          # Example options (adjust based on your project):
          let project_args = [
              "-DBUILD_TESTING=OFF",
              "-DBUILD_EXAMPLES=OFF",
              "-DBUILD_DOCS=OFF",
              # "-DENABLE_FEATURE_X=ON",
              # "-DWITH_LIBRARY_Y=ON",
          ]

          $cmake_args = ($cmake_args | append $project_args)

          # Add any additional CMAKE_ARGS from environment
          if (($env.CMAKE_ARGS? | is-empty) == false) {
              $cmake_args = ($cmake_args | append ($env.CMAKE_ARGS | split row " "))
          }

          # Configure
          print "Configuring with CMake..."
          run-external cmake ...$cmake_args $env.SRC_DIR

          # Build
          print $"Building with ($env.CPU_COUNT) parallel jobs..."
          run-external cmake --build . --parallel $env.CPU_COUNT

          # Install
          print "Installing..."
          run-external cmake --install .

      } else if ("Makefile" | path exists) {
          print "Building with Make..."

          # TODO: Adjust make targets based on your project
          run-external make -j $env.CPU_COUNT
          run-external make install PREFIX=$install_prefix

      } else if ("meson.build" | path exists) {
          print "Building with Meson..."

          # Configure with meson
          meson setup builddir `
              $"--prefix=($install_prefix)" `
              --buildtype=release

          # Build and install
          meson compile -C builddir -j $env.CPU_COUNT
          meson install -C builddir

      } else {
          error make {msg: "No recognized build system found (CMake, Make, or Meson)"}
      }

      # Validate installation
      print "Validating installation..."

      # Check that at least one executable was installed
      let executables = (ls $bin_dir | where type == "file")

      if ($nu.os-info.name == "windows") {
          # On Windows, filter for .exe files
          let exe_files = ($executables | where name =~ '\.exe$')
          if ($exe_files | length) == 0 {
              error make {msg: "No executables were installed!"}
          }
          print $"Found ($exe_files | length) executables"
      } else {
          # On Unix, check for executable permission
          if ($executables | length) == 0 {
              error make {msg: "No files were installed to bin/"}
          }
          print $"Found ($executables | length) files in bin/"
      }

      print "Build completed successfully!"

requirements:
  build:
    - nushell
    - ${{ compiler('c') }}
    - ${{ compiler('cxx') }}
    - cmake
    - ninja
    - pkg-config
    # TODO: Add any additional build tools (e.g., make, meson, autotools)
  host:
    # TODO: Add libraries your application links against
    # Examples:
    # - libcurl
    # - openssl
    # - boost-cpp
    # - qt-main  # for Qt applications
    # - gtk3     # for GTK applications
  run:
    # Run dependencies are often automatically added via run_exports
    # from host dependencies. Only add explicit run dependencies if needed.
    # TODO: Add any runtime-only dependencies

tests:
  # Test 1: Check that executables exist and run
  - script:
      # TODO: Update with your actual executable names
      - ${{ name }} --version
      - ${{ name }} --help

  # Test 2: More comprehensive functionality test using nushell
  - script:
      interpreter: nu
      content: |
        print "Testing ${{ name }} functionality..."

        # Test basic execution
        let version_output = (run-external ${{ name }} --version | complete)

        if $version_output.exit_code != 0 {
            error make {msg: "Failed to run ${{ name }} --version"}
        }

        # TODO: Add more specific tests for your application
        # Example: Test with input file
        # "test input" | save test.txt
        # run-external ${{ name }} process test.txt -o output.txt
        # let result = (open output.txt)
        # if $result != "expected output" {
        #     error make {msg: "Output mismatch"}
        # }

        print "All tests passed!"

  # Test 3: Check for required files
  - package_contents:
      files:
        # Executables location differs on Windows
        - ${{ "Library/" if win }}bin/${{ name }}${{ ".exe" if win }}
        # TODO: Add any other executables or support files

about:
  homepage: https://github.com/example/${{ name }} # TODO: Update URL
  license: MIT # TODO: Update license
  license_file: LICENSE # TODO: Verify license file name
  summary: Short description of the application # TODO: Update
  description: |
    A longer description of what this C++ application does.
    It can span multiple lines and should explain the key features
    and use cases of the application.

    TODO: Replace with actual description
  documentation: https://example.github.io/${{ name }}/ # TODO: Update URL
  repository: https://github.com/example/${{ name }} # TODO: Update URL

extra:
  recipe-maintainers:
    - github-username # TODO: Add actual maintainer GitHub usernames
