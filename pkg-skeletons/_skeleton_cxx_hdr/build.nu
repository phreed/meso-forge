#!/usr/bin/env nu
# External build script for complex C++ header-only library builds
# This script is used when the build process is too complex for inline YAML
# Place this file next to recipe.yaml and reference it with:
#   build:
#     script: build.nu

# Build configuration
let config = {
    # Determine platform-specific settings
    install_prefix: (if ($nu.os-info.name == "windows") { $env.LIBRARY_PREFIX } else { $env.PREFIX })
    is_windows: ($nu.os-info.name == "windows")
    is_macos: ($nu.os-info.name == "macos")
    is_linux: ($nu.os-info.name == "linux")

    # Build options (can be overridden by environment variables)
    build_tests: ($env.BUILD_TESTS? | default false | into bool)
    build_examples: ($env.BUILD_EXAMPLES? | default false | into bool)
    build_docs: ($env.BUILD_DOCS? | default false | into bool)
    build_type: ($env.CMAKE_BUILD_TYPE? | default "Release")

    # Number of parallel jobs
    job_count: ($env.CPU_COUNT? | default (sys | get cpu | length) | into int)
}

# Logging functions
def "log info" [message: string] {
    print $"[($env.PKG_NAME)] INFO: ($message)"
}

def "log warning" [message: string] {
    print $"[(ansi yellow)($env.PKG_NAME)] WARNING: ($message)(ansi reset)"
}

def "log error" [message: string] {
    print $"[(ansi red)($env.PKG_NAME)] ERROR: ($message)(ansi reset)"
}

def "log success" [message: string] {
    print $"[(ansi green)($env.PKG_NAME)] SUCCESS: ($message)(ansi reset)"
}

# Function to find headers in various locations
def find-headers [] {
    let possible_dirs = [
        "include"
        "src"
        $"src/($env.PKG_NAME)"
        "headers"
        $env.PKG_NAME
        "."
    ]

    for dir in $possible_dirs {
        if ($dir | path exists) {
            let headers = (ls ($dir | path expand) --all | where type == "file" | where name =~ '\.(h|hpp|hxx|hh|H)$')
            if ($headers | length) > 0 {
                return {dir: $dir, headers: $headers}
            }
        }
    }

    return null
}

# Function to install headers preserving directory structure
def install-headers [source_dir: string, target_dir: string] {
    log info $"Installing headers from ($source_dir) to ($target_dir)"

    # Create target directory
    mkdir $target_dir

    # Find all headers and preserve directory structure
    let headers = (ls ($source_dir | path expand) --all | where type == "file" | where name =~ '\.(h|hpp|hxx|hh|H)$')

    for header in $headers {
        let rel_path = ($header.name | path relative-to $source_dir)
        let target_path = ($target_dir | path join $rel_path)
        let target_parent = ($target_path | path dirname)

        mkdir $target_parent
        cp $header.name $target_path
    }

    log info $"Installed ($headers | length) header files"
}

# Function to generate CMake config files
def generate-cmake-config [install_prefix: string, lib_name: string, version: string] {
    let cmake_dir = ($install_prefix | path join "share" "cmake" $lib_name)
    mkdir $cmake_dir

    # Generate basic Config.cmake file
    let config_content = $"# ($lib_name) CMake Configuration File
# Generated by rattler-build

@PACKAGE_INIT@

include\(CMakeFindDependencyMacro\)

# Add any required dependencies here
# find_dependency\(SomeDependency\)

# Define the library target
if\(NOT TARGET ($lib_name)::($lib_name)\)
    add_library\(($lib_name)::($lib_name) INTERFACE IMPORTED\)
    set_target_properties\(($lib_name)::($lib_name) PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES \"$\{PACKAGE_PREFIX_DIR\}/include\"
    \)
endif\(\)
"

    $config_content | save -f ($cmake_dir | path join $"($lib_name)Config.cmake")

    # Generate ConfigVersion.cmake file
    let version_content = $"# ($lib_name) Version File
set\(PACKAGE_VERSION \"($version)\"\)

if\(PACKAGE_VERSION VERSION_EQUAL PACKAGE_FIND_VERSION\)
    set\(PACKAGE_VERSION_EXACT TRUE\)
endif\(\)

if\(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION\)
    set\(PACKAGE_VERSION_COMPATIBLE FALSE\)
else\(\)
    set\(PACKAGE_VERSION_COMPATIBLE TRUE\)
endif\(\)
"

    $version_content | save -f ($cmake_dir | path join $"($lib_name)ConfigVersion.cmake")

    log info "Generated CMake configuration files"
}

# Function to generate pkg-config file
def generate-pkgconfig [install_prefix: string, lib_name: string, version: string, description: string] {
    let pc_dir = ($install_prefix | path join "share" "pkgconfig")
    mkdir $pc_dir

    let pc_content = $"prefix=($install_prefix)
exec_prefix=$\{prefix\}
includedir=$\{prefix\}/include

Name: ($lib_name)
Description: ($description)
Version: ($version)
Cflags: -I$\{includedir\}
"

    $pc_content | save -f ($pc_dir | path join $"($lib_name).pc")

    log info "Generated pkg-config file"
}

# Build with CMake
def build-cmake [] {
    log info "Building with CMake..."

    # Check for CMakeLists.txt
    if not ("CMakeLists.txt" | path exists) {
        error make {msg: "CMakeLists.txt not found"}
    }

    # Create build directory
    mkdir build
    cd build

    # Prepare CMake arguments
    mut cmake_args = [
        "-GNinja"
        $"-DCMAKE_INSTALL_PREFIX=($config.install_prefix)"
        $"-DCMAKE_BUILD_TYPE=($config.build_type)"
        $"-DBUILD_TESTING=($config.build_tests | into string | str upcase)"
        $"-DBUILD_EXAMPLES=($config.build_examples | into string | str upcase)"
    ]

    # Add any extra CMAKE_ARGS from environment
    if ($env.CMAKE_ARGS? != null) and (($env.CMAKE_ARGS? | str trim | str length) > 0) {
        $cmake_args = ($cmake_args | append ($env.CMAKE_ARGS | split row " " | where {|x| ($x | str trim | str length) > 0}))
    }

    # Configure
    log info "Configuring with CMake..."
    run-external cmake ...$cmake_args $env.SRC_DIR

    # Build if needed (some header-only libs have tools/tests)
    if $config.build_tests or $config.build_examples {
        log info "Building targets..."
        run-external cmake "--build" "." "--parallel" ($config.job_count | into string)
    }

    # Install
    log info "Installing..."
    run-external cmake "--install" "."

    cd ..
}

# Build with Meson
def build-meson [] {
    log info "Building with Meson..."

    if not ("meson.build" | path exists) {
        error make {msg: "meson.build not found"}
    }

    # Configure
    let meson_args = [
        "setup"
        "builddir"
        $"--prefix=($config.install_prefix)"
        "--buildtype=release"
        $"-Dtests=($config.build_tests | into string | str downcase)"
        $"-Dexamples=($config.build_examples | into string | str downcase)"
    ]

    run-external meson ...$meson_args

    # Install
    run-external meson "install" "-C" "builddir"
}

# Build with Make
def build-make [] {
    log info "Building with Make..."

    if not ("Makefile" | path exists) {
        error make {msg: "Makefile not found"}
    }

    # Most header-only libraries with Makefiles just copy files
    if $config.is_windows {
        # On Windows, we might need to use MSYS2 make or nmake
        log warning "Make on Windows requires MSYS2 or similar environment"
    }

    run-external make "install" $"PREFIX=($config.install_prefix)"
}

# Manual installation
def build-manual [] {
    log info "No build system detected, performing manual installation..."

    # Find headers
    let header_info = (find-headers)

    if $header_info == null {
        error make {msg: "No header files found in common locations"}
    }

    log info $"Found ($header_info.headers | length) headers in ($header_info.dir)"

    # Determine installation structure
    let include_dir = ($config.install_prefix | path join "include")

    # Check if headers should be installed in a subdirectory
    let target_dir = if ($header_info.dir in ["include", "."]) {
        $include_dir
    } else {
        ($include_dir | path join $env.PKG_NAME)
    }

    # Install headers
    install-headers $header_info.dir $target_dir

    # Generate configuration files
    generate-cmake-config $config.install_prefix $env.PKG_NAME $env.PKG_VERSION
    generate-pkgconfig $config.install_prefix $env.PKG_NAME $env.PKG_VERSION "Header-only C++ library"

    # Copy license files if present
    let license_files = (ls | where name =~ '(?i)^(LICENSE|LICENCE|COPYING)')
    if ($license_files | length) > 0 {
        let doc_dir = ($config.install_prefix | path join "share" "doc" $env.PKG_NAME)
        mkdir $doc_dir

        for license in $license_files {
            cp $license.name $doc_dir
        }

        log info $"Copied ($license_files | length) license files"
    }
}

# Validation function
def validate-installation [] {
    log info "Validating installation..."

    let include_base = ($config.install_prefix | path join "include")

    # Check for headers
    if not ($include_base | path exists) {
        error make {msg: "Include directory was not created"}
    }

    let installed_headers = (ls $include_base --all | where type == "file" | where name =~ '\.(h|hpp|hxx|hh|H)$')

    if ($installed_headers | length) == 0 {
        error make {msg: "No header files were installed"}
    }

    log success $"Found ($installed_headers | length) installed header files"

    # Check for CMake files
    let cmake_dir = ($config.install_prefix | path join "share")

    if ($cmake_dir | path exists) {
        let cmake_files = (ls $cmake_dir --all | where type == "file" | where name =~ 'Config\.cmake$')
        if ($cmake_files | length) > 0 {
            log success $"Found ($cmake_files | length) CMake configuration files"
        }
    }

    # Check for pkg-config files
    if ($cmake_dir | path exists) {
        let pc_files = (ls $cmake_dir --all | where type == "file" | where name =~ '\.pc$')
        if ($pc_files | length) > 0 {
            log success $"Found ($pc_files | length) pkg-config files"
        }
    }

    # Print summary
    log info "Installation summary:"
    log info $"  Install prefix: ($config.install_prefix)"
    log info $"  Headers: ($installed_headers | length) files"

    let total_size = ($installed_headers | get size | math sum)
    let size_kb = (($total_size / 1024) | math round)
    log info $"  Total size: ($size_kb) KB"
}

# Main build process
def main [] {
    log info $"Building ($env.PKG_NAME) version ($env.PKG_VERSION)"
    log info $"Platform: ($nu.os-info.name) ($nu.os-info.arch)"
    log info $"Install prefix: ($config.install_prefix)"

    # Save current directory
    let original_dir = (pwd)

    try {
        # Determine and execute build method
        if ("CMakeLists.txt" | path exists) {
            build-cmake
        } else if ("meson.build" | path exists) {
            build-meson
        } else if ("Makefile" | path exists) {
            build-make
        } else {
            build-manual
        }

        # Validate installation
        validate-installation

        log success "Build completed successfully!"

    } catch { |e|
        log error $"Build failed: ($e.msg)"
        cd $original_dir
        exit 1
    }

    # Return to original directory
    cd $original_dir
}

# Run main
main
