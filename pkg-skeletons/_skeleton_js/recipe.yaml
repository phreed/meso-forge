# yaml-language-server: $schema=https://raw.githubusercontent.com/prefix-dev/recipe-format/main/schema.json
schema_version: 1

context:
  version: 1.0.0

package:
  name: {{ PACKAGE_NAME }}
  version: ${{ version }}

source:
  # For simple npm packages (recommended for most cases):
  - url: https://registry.npmjs.org/{{ PACKAGE_NAME }}/-/{{ PACKAGE_NAME }}-${{ version }}.tgz
    sha256: {{ SHA256_HASH }}
    file_name: {{ PACKAGE_NAME }}-${{ version }}.tgz

  # For GitHub source builds (complex packages, monorepos, or when npm tarball insufficient):
  # - url: https://github.com/{{ GITHUB_USER }}/{{ REPO_NAME }}/archive/refs/tags/v${{ version }}.tar.gz
  #   sha256: {{ SHA256_HASH }}

  # For workspace/monorepo builds that need additional files:
  # - url: https://github.com/{{ GITHUB_USER }}/{{ REPO_NAME }}/archive/refs/tags/v${{ version }}.tar.gz
  #   sha256: {{ SHA256_HASH }}

  - path: ../../.scripts/npm_licenses.nu
    file_name: npm_licenses.nu

build:
  # Use noarch for pure JavaScript packages without native dependencies
  noarch: generic
  script: |
    # BUILD PATTERN 1: Simple npm package installation (recommended for most cases)
    # This works for packages that don't need compilation or complex setup
    npm install -g ./{{ PACKAGE_NAME }}-${{ version }}.tgz --prefix $PREFIX

    # BUILD PATTERN 2: Complex package build from source (use when npm tarball insufficient)
    # Uncomment and modify as needed for complex builds:

    # # Fix problematic postinstall scripts (common issue with electron/desktop packages)
    # # sed -i 's/"postinstall": "electron-rebuild",/"postinstall": "echo Skipping electron-rebuild",/' package.json
    # # sed -i 's/"postinstall": ".*problematic-script.*",/"postinstall": "echo Skipping problematic script",/' apps/*/package.json

    # # Install dependencies (choose appropriate method):
    # npm ci                           # For package-lock.json (recommended)
    # # npm install                    # For packages without lockfile
    # # yarn install                   # For yarn.lock

    # # Build the package (if build step required):
    # npm run build                    # Standard build script
    # # npm run build:prod             # Production build
    # # npm run compile                # For TypeScript/compilation

    # # For CLI tools, create global installation:
    # npm install -g . --prefix $PREFIX

    # BUILD PATTERN 3: Complex application with runtime dependencies
    # Use when bundling fails and you need to package the full application with dependencies:

    # # Build application
    # npm run build:prod
    #
    # # Copy application files to package
    # mkdir -p $PREFIX/lib/{{ PACKAGE_NAME }}
    # cp -r build/* $PREFIX/lib/{{ PACKAGE_NAME }}/
    #
    # # Copy runtime dependencies (only if bundling insufficient)
    # mkdir -p $PREFIX/lib/{{ PACKAGE_NAME }}/node_modules
    # cp -r node_modules/* $PREFIX/lib/{{ PACKAGE_NAME }}/node_modules/
    #
    # # Create wrapper script for CLI tools
    # mkdir -p $PREFIX/bin
    # cat > $PREFIX/bin/{{ PACKAGE_NAME }} << 'EOF'
    # #!/bin/bash
    # export NODE_PATH="$PREFIX/lib/{{ PACKAGE_NAME }}/node_modules:$NODE_PATH"
    # exec node "$PREFIX/lib/{{ PACKAGE_NAME }}/main.js" "$@"
    # EOF
    # chmod +x $PREFIX/bin/{{ PACKAGE_NAME }}

    # Generate license summary (keep this for all patterns)
    nu npm_licenses.nu | save license_summary.txt

requirements:
  build:
    - nushell              # For license summary generation
    - nodejs               # Node.js runtime for building
    - npm                  # Package manager
    # Add these for complex builds as needed:
    # - yarn                # Alternative package manager
    # - webpack             # Module bundler
    # - webpack-cli         # Webpack CLI
    # - typescript          # TypeScript compiler
    # - cross-env           # Cross-platform environment variables
    # - copy-webpack-plugin # Webpack plugins
    # - webpack-node-externals
    # - tsconfig-paths-webpack-plugin
    # - ts-loader

  # For GitHub source builds, may need additional tools:
  # - git
  # - python              # For node-gyp native builds
  # - make                # For native compilation
  # - {{ compiler('c') }} # For native modules

  run:
    - nodejs
    # For complex applications that include dependencies:
    # Add specific runtime dependencies here based on package needs
    # Common examples:
    # - python              # If package uses Python scripts
    # - git                 # If package needs git at runtime

tests:
  - script:
      # TEST PATTERN 1: CLI tool tests (for command-line applications)
      - {{ PACKAGE_NAME }} --version    # Version check (exits with 0 on success)
      # - {{ PACKAGE_NAME }} --help      # Help check (may exit with 1, use carefully)

      # TEST PATTERN 2: Module import tests (for libraries)
      # - node -e "require('{{ PACKAGE_NAME }}')"                    # Basic require test
      # - node -e "console.log(typeof require('{{ PACKAGE_NAME }}')" # Type check
      # - node -e "const pkg = require('{{ PACKAGE_NAME }}'); console.log(pkg.version || 'no version')" # Version test

      # TEST PATTERN 3: Functional tests (for more comprehensive testing)
      # - node -e "const pkg = require('{{ PACKAGE_NAME }}'); pkg.someFunction()" # Function test
      # - echo "test input" | {{ PACKAGE_NAME }} --stdin              # Input processing test
      # - {{ PACKAGE_NAME }} --validate-config ./test-config.json    # Config validation test

about:
  homepage: {{ HOMEPAGE_URL }}
  summary: {{ PACKAGE_SUMMARY }}
  description: |
    {{ PACKAGE_DESCRIPTION }}

    Key features:
    - Feature 1
    - Feature 2
    - Feature 3
  license: {{ LICENSE }}
  license_file:
    - LICENSE                          # From source package
    # - LICENSE.txt                    # Alternative license file name
    # - COPYING                        # GPL-style license file
    - license_summary.txt              # Generated license summary
  documentation: {{ HOMEPAGE_URL }}/docs/
  repository: {{ DEV_URL }}

# Common license values for JavaScript packages:
# - MIT                    (most common)
# - Apache-2.0
# - BSD-3-Clause
# - ISC
# - GPL-3.0-or-later
# - LGPL-3.0-or-later

extra:
  recipe-maintainers:
    - {{ MAINTAINER_GITHUB_USERNAME }}

  # Additional platforms for pure JavaScript packages
  # additional-platforms:
  #   - linux-aarch64
  #   - osx-arm64

  # Skip builds on certain conditions
  # skip-lints:
  #   - missing_hash          # If using git source without hash
  #   - should_be_noarch      # If package should be noarch but isn't

  # For packages with optional native dependencies
  # skip: True  # [win and py<38]

# COMMON PATTERNS AND EXAMPLES:
#
# 1. SIMPLE CLI TOOL (like bibtex-tidy):
#    - Use npm tarball source
#    - npm install -g with --prefix
#    - Test with --version
#    - noarch: generic
#
# 2. COMPLEX APPLICATION (like bitwarden-cli):
#    - Use GitHub source for full workspace
#    - npm ci for workspace dependencies
#    - Fix problematic postinstall scripts
#    - npm run build for compilation
#    - Copy build output and dependencies
#    - Create wrapper script
#    - Test with specific commands
#
# 3. TYPESCRIPT LIBRARY:
#    - Add typescript to build requirements
#    - npm run build for compilation
#    - Include .d.ts files in package
#    - Test with require() calls
#
# 4. WEB FRAMEWORK/LIBRARY:
#    - Include webpack/rollup in build
#    - May need browser testing setup
#    - Consider peer dependencies
#    - Test with import statements
#
# 5. MONOREPO PACKAGE:
#    - Use GitHub source
#    - cd to specific package directory
#    - Handle workspace dependencies
#    - May need lerna/nx tools
